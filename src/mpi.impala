
type size_t = u64;

type COMM_Comm = &();
type COMM_Datatype = &();
type COMM_Op = &();
type MPI_Request = &();
type MPI_Status = &mut [i8];
type MPI_Buf = &[i8];
type MPI_MutBuf = &mut [i8];

//TODO
type COMM_REQUEST = MPI_Request;
type COMM_Buf = MPI_Buf;
type COMM_MutBuf = MPI_MutBuf;
type COMM_Status = MPI_Status;

//TODO: check MPI_Status / COMM_Status

extern "C" {
    fn anydsl_comm_init() -> i32;
    fn anydsl_comm_initialized(&mut i32) -> i32;
    fn anydsl_comm_size(COMM_Comm, &mut i32) -> i32;
    fn anydsl_comm_rank(COMM_Comm, &mut i32) -> i32;
    fn anydsl_comm_allreduce(COMM_Buf, COMM_MutBuf, i32, COMM_Datatype, COMM_Op, COMM_Comm) -> i32;
    fn anydsl_comm_send(COMM_Buf, i32, COMM_Datatype, i32, i32, COMM_Comm) -> i32;
    fn anydsl_comm_recv(COMM_MutBuf, i32, COMM_Datatype, i32, i32, COMM_Comm, COMM_Status) -> i32;
    fn anydsl_comm_irecv(COMM_MutBuf, i32, COMM_Datatype, i32, i32, COMM_Comm, &COMM_REQUEST) -> i32;
    fn anydsl_comm_wait(&COMM_REQUEST, &mut COMM_Status) -> i32;
    fn anydsl_comm_probe(i32, i32, COMM_Comm, COMM_Status) -> i32;
    fn anydsl_comm_get_count(COMM_Status, COMM_Datatype, &mut i32) -> i32;
    fn anydsl_comm_gather(COMM_Buf, i32, COMM_Datatype, COMM_MutBuf, i32, COMM_Datatype, i32, COMM_Comm) -> i32;
    fn anydsl_comm_allgather(COMM_Buf, i32, COMM_Datatype, COMM_MutBuf, i32, COMM_Datatype, COMM_Comm) -> i32;
    fn anydsl_comm_barrier(COMM_Comm) -> i32;
    fn anydsl_comm_wtime() -> f64;
    fn anydsl_comm_finalize() -> i32;
    fn anydsl_comm_finalized(&mut i32) -> i32;
    // wrappers for getting constants
    fn anydsl_comm_get_world() -> COMM_Comm;
    fn anydsl_comm_get_int() -> COMM_Datatype;
    fn anydsl_comm_get_double() -> COMM_Datatype;
    fn anydsl_comm_get_char() -> COMM_Datatype;
    fn anydsl_comm_get_byte() -> COMM_Datatype;
    fn anydsl_comm_get_max() -> COMM_Op;
    fn anydsl_comm_get_sum() -> COMM_Op;
    fn anydsl_comm_get_status_ignore() -> COMM_Status;
    fn exit(int) -> ();
}

struct MPIComms {
    world : COMM_Comm,
}

struct MPIOps {
    max : COMM_Op,
    sum : COMM_Op,
}

// TODO should be autogenerated, differs for other MPI implementations (e.g. MPICH)
struct MPIStatus {
    source : i32,
    tag : i32,
    error : i32,
    // internal to openmpi, do not access
    _cancelled : i32,
    _ucount : u64
}

struct MPIStatuses {
    ignore : &mut MPIStatus,
}

struct Communicator {
    comms : MPIComms,
    ops : MPIOps,
    status : MPIStatuses,
    int_t : COMM_Datatype,
    double_t : COMM_Datatype,
    init : fn() -> i32,
    comm_size : fn(COMM_Comm, &mut i32) -> i32,
    comm_rank : fn(COMM_Comm, &mut i32) -> i32,
    allreduce : fn(MPI_Buf, MPI_MutBuf, i32, COMM_Datatype, COMM_Op, COMM_Comm) -> i32,
    send : fn(MPI_Buf, i32, COMM_Datatype, i32, i32, COMM_Comm) -> i32,
    recv : fn(MPI_MutBuf, i32, COMM_Datatype, i32, i32, COMM_Comm, &mut MPIStatus) -> i32,
    irecv : fn(MPI_MutBuf, i32, COMM_Datatype, i32, i32, COMM_Comm, &MPI_Request) -> i32,
    wait : fn(&MPI_Request, &mut MPI_Status) -> i32,
    probe: fn(i32, i32, COMM_Comm, &mut MPIStatus) -> i32,
    get_count: fn(&mut MPIStatus, COMM_Datatype, &mut i32) -> i32,
    gather: fn(MPI_Buf, i32, COMM_Datatype, MPI_MutBuf, i32, COMM_Datatype, i32, COMM_Comm) -> i32,
    barrier : fn(COMM_Comm) -> i32,
    wtime : fn() -> f64,
    finalize : fn() -> i32,
}

fn @comm() -> Communicator {
    Communicator {
        comms : MPIComms {
            world : anydsl_comm_get_world(),
        },
        ops : MPIOps {
            max : anydsl_comm_get_max(),
            sum : anydsl_comm_get_sum(),
        },
        status : MPIStatuses {
            ignore : anydsl_comm_get_status_ignore() as &mut MPIStatus,
        },
        double_t : anydsl_comm_get_double(),
        int_t : anydsl_comm_get_int(),
        init : anydsl_comm_init,
        comm_size : anydsl_comm_size,
        comm_rank : anydsl_comm_rank,
        allreduce : anydsl_comm_allreduce,
        send : anydsl_comm_send,
        recv : @|buf, count, datatype, source, tag, comm, status| {
            anydsl_comm_recv(buf, count, datatype, source, tag, comm, status as MPI_Status)
        },
        irecv : anydsl_comm_irecv,
        wait : anydsl_comm_wait,
        probe: @|source, tag, comm, status| {
            anydsl_comm_probe(source, tag, comm, status as MPI_Status)
        },
        get_count: @|status, datatype, count| {
            anydsl_comm_get_count(status as MPI_Status, datatype, count)
        },
        gather: anydsl_comm_gather,
        barrier : anydsl_comm_barrier,
        wtime : anydsl_comm_wtime,
        finalize : anydsl_comm_finalize,
    }
}

;
